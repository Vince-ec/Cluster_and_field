

Python 3.5.5 |Anaconda, Inc.| (default, Apr 26 2018, 08:11:22) 
Type 'copyright', 'credits' or 'license' for more information
IPython 6.4.0 -- An enhanced Interactive Python. Type '?' for help.
​

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from astropy.io import fits
from astropy import wcs
from astropy.table import Table
from scipy.interpolate import interp1d, interp2d
from glob import glob
import os
from spec_exam import Gen_spec
from grizli import multifit
from grizli import model
from astropy.cosmology import Planck13 as cosmo
import fsps
from C_full_fit import Scale_model_mult, Stitch_spec
from time import time
from sim_engine import *
from matplotlib import gridspec
hpath = os.environ['HOME'] + '/'
​
"""
class:
​
def:
Best_fitter
Best_fitter_sim
Redshift_fitter
Best_fit_model
Stich_resize_and_fit
Stich_grids
Fit
Resize
Gen_grid  
Set_params
Set_rshift_params
Simple_analyze
Redshift_analyze
​
"""
​
if hpath == '/home/vestrada78840/':
    from C_spec_tools import Source_present, Photometry, Scale_model, Oldest_galaxy
    data_path = '/fdata/scratch/vestrada78840/data/'
    model_path ='/fdata/scratch/vestrada78840/fsps_spec/'
    chi_path = '/fdata/scratch/vestrada78840/chidat/'
    spec_path = '/fdata/scratch/vestrada78840/stack_specs/'
    beam_path = '/fdata/scratch/vestrada78840/clear_q_beams/'
    template_path = '/fdata/scratch/vestrada78840/data/'
    out_path = '/home/vestrada78840/chidat/'
    phot_path = '/fdata/scratch/vestrada78840/phot/'
    temp_out = '/tmp/'
    
else:
    from spec_tools import Source_present, Photometry, Scale_model, Oldest_galaxy
    data_path = '../data/'
    model_path = hpath + 'fsps_models_for_fit/fsps_spec/'
    chi_path = '../chidat/'
    spec_path = '../spec_files/'
    beam_path = '../beams/'
    template_path = '../templates/'
    out_path = '../data/posteriors/'
    phot_path = '../phot/'
    temp_out = '../data/tmp/'

def Get_posteriors(field, galaxy, specz):
    versions = len(glob(temp_out + 'tmp_chi_*')) // 5
​
    # get true minimum
    MIN = 1E18
    for i in range(versions):
        for ii in range(5):
            chi = np.load(temp_out + 'tmp_chi_{0}_v{1}.npy'.format(ii,i))
            if np.min(chi) < MIN:
                MIN = np.min(chi)
​
    # rederive P(z)s
    for i in range(versions):
        g1,g2 = np.load(temp_out + 'tmp_grism_combo_v{0}.npy'.format(i))
        bfm,bfa,bft,bfz,bfd = np.load(temp_out + 'tmp_best_fits_v{0}.npy'.format(i))
        
        bfm = np.append([1],bfm)
        bfa = np.append([1],bfa)
        bft = np.append([1],bft)
        bfz = np.append([specz],bfz)
        bfd = np.append([1],bfd)
        
        for ii in range(5):
            mdist, adist, tdist, zdist, ddist = Set_params(bfm[ii], bfa[ii], bft[ii], bfz[ii], bfd[ii], ii, 
                            alims = [[0.1, 8.2], 2.0, 0.8, 0.8, 0.8,],astep = [0.5, 0.25, 0.1, 0.05, 0.05])
            
            chi = np.load(temp_out + 'tmp_chi_{0}_v{1}.npy'.format(ii,i))
            PZ, Pt, Ptau, Pz, Pd =  Full_analyze(chi, MIN, mdist, adist, tdist, zdist, ddist, ii, i)
            
            np.save(temp_out + 'tmp_PZ_{0}_v{1}'.format(ii,i), [mdist,PZ])
            np.save(temp_out + 'tmp_Pt_{0}_v{1}'.format(ii,i), [adist,Pt])
            np.save(temp_out + 'tmp_Ptau_{0}_v{1}'.format(ii,i), [tdist,Ptau])
            np.save(temp_out + 'tmp_Pr_{0}_v{1}'.format(ii,i), [zdist,Pz])
            np.save(temp_out + 'tmp_Pd_{0}_v{1}'.format(ii,i), [ddist,Pd])
​
    posteriors = ['PZ', 'Pt', 'Ptau', 'Pr', 'Pd']
            
    for P in posteriors:      
        hr, p_stack = Stack_P( P, versions)
        #save result
        np.save(out_path + '{0}_{1}_{2}'.format(field, galaxy, P), [hr,p_stack])
    
    #remove temporary files
#     all_temps = glob(temp_out + 'tmp*npy')
#     [os.remove(U) for U in all_temps]
  
def Setmin(P0,X0,P1,X1):
    setmin = X1[P1 == min(P1)]
    return interp1d(X0, P0)(setmin) / min(P1)
    
def Stack_P(Px, versions):
    minx, maxx = 1E5, 0 
    for i in range(5):
        x, dummy = np.load(temp_out + 'tmp_{0}_{1}_v0.npy'.format(Px,i))
​
        if x[0] < minx:
            minx =x[0]
​
        if x[-1] > maxx:
            maxx =x[-1]
​
    dx, dummy = np.load(temp_out + 'tmp_{0}_4_v0.npy'.format(Px))
    dx = dx[1] - dx[0]
​
    hr = np.arange(minx, maxx+ dx, dx)
​
    ygrid = np.zeros([5 * versions, len(hr)])
    wgrid = np.zeros(ygrid.shape)
​
    for i in range(versions):
        setmin = 1
        for ii in range(5):
            y, Py = np.load(temp_out + 'tmp_{0}_{1}_v{2}.npy'.format(Px, ii, i))
            Py[~(Py**2 > 0)] = 0
​
#             if ii > 0:
#                 u, Pu = np.load(temp_out + 'tmp_{0}_{1}_v{2}.npy'.format(Px, ii - 1, i))
#                 Pu[~(Pu**2 > 0)] = 0
#                 if Setmin(Pu,u,Py,y)**2 > 0 and (1 /Setmin(Pu,u,Py,y))**2 > 0:
#                     setmin *=  Setmin(Pu,u,Py,y)
​
            iP = interp1d(y,Py * setmin)
            for iii in range(len(hr)):
                if y[0] <= hr[iii] <= y[-1]:
                    ygrid[i*5 + ii][iii] = iP(hr[iii])
                    wgrid[i*5 + ii][iii] = 1                
    #stack posteriors
    p_stack = np.zeros(len(hr))
    for i in range(len(hr)):
        p_stack[i] = np.sum(ygrid.T[i] * wgrid.T[i]) / (np.sum(wgrid.T[i]))
​
    p_stack[~(p_stack**2 > 0)] = 0
​
    return hr, p_stack / np.trapz(p_stack,hr)

from spec_id import Set_params, Full_analyze

######

Get_posteriors('Test','sim',1.2)

#######

vchi = {}
mdict = {}
adict = {}
tdict = {}
zdict = {}
ddict = {}
​
bfm,bfa,bft,bfz,bfd = np.load(temp_out + 'tmp_best_fits_v0.npy')
​
bfm = np.append([1],bfm)
bfa = np.append([1],bfa)
bft = np.append([1],bft)
bfz = np.append([1.2],bfz)
bfd = np.append([1],bfd)
​
for ii in range(5):
    mdist, adist, tdist, zdist, ddist = Set_params(bfm[ii], bfa[ii], bft[ii], bfz[ii], bfd[ii], ii, 
                    alims = [[0.1, 8.2], 2.0, 0.8, 0.8, 0.8,],astep = [0.5, 0.25, 0.1, 0.05, 0.05])
    
    mdict['m{0}'.format(ii)] = mdist
    adict['a{0}'.format(ii)] = adist
    tdict['t{0}'.format(ii)] = tdist
    zdict['z{0}'.format(ii)] = zdist
    ddict['d{0}'.format(ii)] = ddist
    
    chi = np.load(temp_out + 'tmp_chi_{0}_v0.npy'.format(ii))
    
    vchi['ichi{0}'.format(ii)] = RegularGridInterpolator([mdist, adist, tdist, zdist, ddist],chi)
    
mmin, mmax = Get_minmax(mdict)
amin, amax = Get_minmax(adict)
tmin, tmax = Get_minmax(tdict)
zmin, zmax = Get_minmax(zdict)
dmin, dmax = Get_minmax(ddict)
​
hrm = np.arange(mmin, mmax + 1E-6, mdict['m4'][1] - mdict['m4'][0])
hra = np.arange(amin, amax + 1E-6, adict['a4'][1] - adict['a4'][0])
hrt = np.arange(tmin, tmax + 1E-6, tdict['t4'][1] - tdict['t4'][0])
hrz = np.arange(zmin, zmax + 1E-6, zdict['z4'][1] - zdict['z4'][0])
hrd = np.arange(dmin, dmax + 1E-6, ddict['d4'][1] - ddict['d4'][0])

#########

hrgrid = np.zeros([len(hrm), len(hra), len(hrt), len(hrz), len(hrd)])
​
for i in range(len(hrm)):
    for ii in range(len(hra)):    
        for iii in range(len(hrt)):    
            for iv in range(len(hrz)):    
                for v in range(len(hrd)):   
                    v=Which_version(hrm[i],hra[ii],hrt[iii],hrz[iv],hrd[v])
                    if v == -1:
                        hrgrid[i][ii][iii][iv][v] = 1E9
                    else:
                        hrgrid[i][ii][iii][iv][v] = vchi['ichi{0}'.format(v)]([hrm[i],hra[ii],hrt[iii],hrz[iv],hrd[v]])
